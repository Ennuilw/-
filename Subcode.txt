@bot.command()
async def pic(ctx):
    #print(ctx.message.attachments[0].url)
    msg = await ctx.reply("Please wait a moment.<a:Loading_2:1007527284753834014>")
    r = requests.get(ctx.message.attachments[0].url)
    img = Image.open(io.BytesIO(r.content))
    #img_resize = img.resize((500), int(img.height * 500 / img.width))
    img.save("image.png")
    color_arr = extract_main_color(img_path, 7)
    show_tiled_main_color(color_arr)
    #draw_random_stripe(color_arr, img_path)
    file = discord.File("./image/stripe_image.png", filename="stripe.png")
    await msg.edit(content="Done<a:VerifyMark_1:987128219658514484>",file=file)
"""
def download_img(url, file_name):
    r = requests.get(url, stream=True)
    if r.status_code == 200:
        with open(file_name, 'wb') as f:f.write(r.content)

def draw_random_stripe(color_arr, img_path):
    width = 1024
    height = 1024
    stripe_color_img = Image.new(mode='RGB', size=(width, height), color='#333333')
    current_height = 0
    while current_height < height:
        random_index = random.randrange(color_arr.shape[0])
        color_hex_str = '#%02x%02x%02x' % tuple(color_arr[random_index])
        random_height = random.randrange(5, 70)
        color_img = Image.new(mode='RGB', size=(width, random_height),color=color_hex_str)
        stripe_color_img.paste(im=color_img,box=(0, current_height))
        current_height += random_height
    stripe_color_img.show()
    #stripe_color_img.save('./image/stripe_' + img_path)
"""
def show_tiled_main_color(color_arr):
    IMG_SIZE = 64
    MARGIN = 15
    width = IMG_SIZE * color_arr.shape[0] + MARGIN * 2
    height = IMG_SIZE + MARGIN * 2
    tiled_color_img = Image.new(
        mode='RGB', size=(width, height), color='#333333')
    for i, rgb_arr in enumerate(color_arr):
        color_hex_str = '#%02x%02x%02x' % tuple(rgb_arr)
        color_img = Image.new(mode='RGB', size=(IMG_SIZE, IMG_SIZE),color=color_hex_str)
        tiled_color_img.paste(im=color_img,box=(MARGIN + IMG_SIZE * i, MARGIN))
    #tiled_color_img.show()
    tiled_color_img.save('image\stripe_' + img_path)
def extract_main_color(img_path, color_num):
    cv2_img = cv2.imread(img_path)
    cv2_img = cv2.cvtColor(cv2_img, cv2.COLOR_BGR2RGB)
    cv2_img = cv2_img.reshape((cv2_img.shape[0] * cv2_img.shape[1], 3))
    cluster = KMeans(n_clusters=color_num)
    cluster.fit(X=cv2_img)
    cluster_centers_arr = cluster.cluster_centers_.astype(int, copy=False)
    trans_color = cv2_img[0]
    cluster_centers_arr = np.array([i for i in cluster_centers_arr if LA.norm(np.array(i - trans_color), 2) > 50])
    #print("extracted colors array:")
    #print(cluster_centers_arr)
    return cluster_centers_arr
img_path = 'image.png'






"""    if score >= 45:
        e.title="<:icons_Correct:1007531113591357450>"
        else:
            e.title="<:icons_Wrong:1007531146256580648>"
    else:
        if score >= 30:
            e.title="<:icons_Correct:1007531113591357450>"
        else:
            e.title="<:icons_Wrong:1007531146256580648>
@bot.slash_command(name="原神聖遺物スコア計算", desciption="小数点も要する") # | 聖遺物: 花,羽,杯=1, 時,冠=2
async def _clac_score(ctx,会心率:float=None, 会心ダメージ:float=None, 攻撃_防御力:float=None):
    if not 攻撃_防御力: 攻撃_防御力=0
    if not 会心ダメージ:会心ダメージ=0
    if not 会心率:会心率=0
    score = 攻撃_防御力 + (会心率 * 2) + 会心ダメージ
    e = discord.Embed(description=f"**スコア** : **{round(score, 1)}**\n\n> 会心率```{会心率} %```\n> 会心ダメージ```{会心ダメージ} %```\n> 攻撃力・防御力```{攻撃_防御力} %```", color=fav)
    select = Select(
        placeholder="聖遺物を選択してください",
        options=[
            discord.SelectOption(label="生きの花",value="0x1"),
            discord.SelectOption(label="死の羽",  value="0x2"),
            discord.SelectOption(label="時の砂",  value="0x3"),
            discord.SelectOption(label="空の杯",  value="0x4"),
            discord.SelectOption(label="理の冠",  value="0x5")])
    async def callback(interaction):
        if select.values[0] == "0x3":
            if score >= 45:e.title="<:icons_Correct:1007531113591357450>"
            else:e.title="<:icons_Wrong:1007531146256580648>"
        elif select.values[0] == "0x5":
            if score >= 45:e.title="<:icons_Correct:1007531113591357450>"
            else:e.title="<:icons_Wrong:1007531146256580648>"
        else:
            if score >= 30:e.title="<:icons_Correct:1007531113591357450>"
            else:e.title="<:icons_Wrong:1007531146256580648>"
    select.callback = callback
    #if :
        #if score >= 45:e.title="<:icons_Correct:1007531113591357450>"
        #else:e.title="<:icons_Wrong:1007531146256580648>"
    #else:
        #if score >= 30:e.title="<:icons_Correct:1007531113591357450>"
        #else:e.title="<:icons_Wrong:1007531146256580648>"
    view = View()
    view.add_item(select)
    e.set_footer(text="20Lv想定でサブスコアのみ計算してます | Beta ver")
    await ctx.respond(embed=e, view = view)"""













