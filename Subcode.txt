@bot.command()
async def pic(ctx):
    #print(ctx.message.attachments[0].url)
    msg = await ctx.reply("Please wait a moment.<a:Loading_2:1007527284753834014>")
    r = requests.get(ctx.message.attachments[0].url)
    img = Image.open(io.BytesIO(r.content))
    #img_resize = img.resize((500), int(img.height * 500 / img.width))
    img.save("image.png")
    color_arr = extract_main_color(img_path, 7)
    show_tiled_main_color(color_arr)
    #draw_random_stripe(color_arr, img_path)
    file = discord.File("./image/stripe_image.png", filename="stripe.png")
    await msg.edit(content="Done<a:VerifyMark_1:987128219658514484>",file=file)
"""
def download_img(url, file_name):
    r = requests.get(url, stream=True)
    if r.status_code == 200:
        with open(file_name, 'wb') as f:f.write(r.content)

def draw_random_stripe(color_arr, img_path):
    width = 1024
    height = 1024
    stripe_color_img = Image.new(mode='RGB', size=(width, height), color='#333333')
    current_height = 0
    while current_height < height:
        random_index = random.randrange(color_arr.shape[0])
        color_hex_str = '#%02x%02x%02x' % tuple(color_arr[random_index])
        random_height = random.randrange(5, 70)
        color_img = Image.new(mode='RGB', size=(width, random_height),color=color_hex_str)
        stripe_color_img.paste(im=color_img,box=(0, current_height))
        current_height += random_height
    stripe_color_img.show()
    #stripe_color_img.save('./image/stripe_' + img_path)
"""
def show_tiled_main_color(color_arr):
    IMG_SIZE = 64
    MARGIN = 15
    width = IMG_SIZE * color_arr.shape[0] + MARGIN * 2
    height = IMG_SIZE + MARGIN * 2
    tiled_color_img = Image.new(
        mode='RGB', size=(width, height), color='#333333')
    for i, rgb_arr in enumerate(color_arr):
        color_hex_str = '#%02x%02x%02x' % tuple(rgb_arr)
        color_img = Image.new(mode='RGB', size=(IMG_SIZE, IMG_SIZE),color=color_hex_str)
        tiled_color_img.paste(im=color_img,box=(MARGIN + IMG_SIZE * i, MARGIN))
    #tiled_color_img.show()
    tiled_color_img.save('image\stripe_' + img_path)
def extract_main_color(img_path, color_num):
    cv2_img = cv2.imread(img_path)
    cv2_img = cv2.cvtColor(cv2_img, cv2.COLOR_BGR2RGB)
    cv2_img = cv2_img.reshape((cv2_img.shape[0] * cv2_img.shape[1], 3))
    cluster = KMeans(n_clusters=color_num)
    cluster.fit(X=cv2_img)
    cluster_centers_arr = cluster.cluster_centers_.astype(int, copy=False)
    trans_color = cv2_img[0]
    cluster_centers_arr = np.array([i for i in cluster_centers_arr if LA.norm(np.array(i - trans_color), 2) > 50])
    #print("extracted colors array:")
    #print(cluster_centers_arr)
    return cluster_centers_arr
img_path = 'image.png'



@bot.command(aliases=["incode"])
async def invitecodeserver(ctx, url):
    if ctx.author.id == s.Dev:
        async with ctx.channel.typing():
            guild = await bot.fetch_invite(url = f"https://discord.gg/{url}")
            date_f= "%Y/%m/%d"
            tchannels= len(guild.text_channels)
            vchannels= len(guild.voice_channels)
            roles= [role for role in guild.roles]
            emojis= [emoji for emoji in guild.emojis]
            online= [1 for user in guild.members if user.status != discord.Status.offline]
            stickers = [sticker  for sticker in guild.stickers]
            embed= discord.Embed(title=f"{guild.name}", description= f":crown: **Owner : **{guild.owner.mention}\n:id: **Server id : `{guild.id}`**", color= 0x6dc1d1)
            try:embed.set_thumbnail(url= guild.icon.url)
            except:pass
            embed.add_field(name= ":shield: Role", value= f"Roles: **{len(roles)}**", inline= True)
            embed.add_field(name= ":grinning: Emoji", value= f"Emojis: **{len(emojis)}**\nStickers: **{len(stickers)}**")
            embed.add_field(name= f":gem: Boost [{guild.premium_subscription_count}]", value= f"Tier: ** {guild.premium_tier}**")
            embed.add_field(name= ":calendar_spiral: Createion", value= f"**`{guild.created_at.strftime(date_f)}`**", inline=True)
            embed.add_field(name= f":busts_in_silhouette: Members [{guild.member_count}]", 
                    value= f"User: **{str(sum(1 for member in guild.members if not member.bot))}** |  Bot: **{str(sum(1 for member in guild.members if member.bot))}**\nOnline: **{len(online)}**")
            embed.add_field(name= f":speech_left: Channels [{tchannels+vchannels}]", 
                    value= f"Text: **{tchannels}** | Voice: **{vchannels}**\nCategory: **{len(guild.categories)}**",inline= True)
            try:
                vanity =  await guild.vanity_invite()
                embed.add_field(name=":link: Vanity URL", value=f"`{str(vanity).replace('https://', '')}`")
            except:embed.add_field(name=":link: Vanity URL", value=f"`None`")        
            try:
                req= await bot.http.request(discord.http.Route("GET", "/guilds/{sid}", sid= guild.id))
                banner_id= req["banner"]
                if banner_id:
                    banner_url= f"https://cdn.discordapp.com/banners/{guild.id}/{banner_id}.png?size=1024"
                    embed.set_image(url= banner_url)
                    embed.set_footer(text= f"By: {str(ctx.author)} | Banner is png file")
            except:embed.set_footer(text= f"By: {str(ctx.author)}")
            await ctx.send(embed= embed)


"""    if score >= 45:
        e.title="<:icons_Correct:1007531113591357450>"
        else:
            e.title="<:icons_Wrong:1007531146256580648>"
    else:
        if score >= 30:
            e.title="<:icons_Correct:1007531113591357450>"
        else:
            e.title="<:icons_Wrong:1007531146256580648>
@bot.slash_command(name="原神聖遺物スコア計算", desciption="小数点も要する") # | 聖遺物: 花,羽,杯=1, 時,冠=2
async def _clac_score(ctx,会心率:float=None, 会心ダメージ:float=None, 攻撃_防御力:float=None):
    if not 攻撃_防御力: 攻撃_防御力=0
    if not 会心ダメージ:会心ダメージ=0
    if not 会心率:会心率=0
    score = 攻撃_防御力 + (会心率 * 2) + 会心ダメージ
    e = discord.Embed(description=f"**スコア** : **{round(score, 1)}**\n\n> 会心率```{会心率} %```\n> 会心ダメージ```{会心ダメージ} %```\n> 攻撃力・防御力```{攻撃_防御力} %```", color=fav)
    select = Select(
        placeholder="聖遺物を選択してください",
        options=[
            discord.SelectOption(label="生きの花",value="0x1"),
            discord.SelectOption(label="死の羽",  value="0x2"),
            discord.SelectOption(label="時の砂",  value="0x3"),
            discord.SelectOption(label="空の杯",  value="0x4"),
            discord.SelectOption(label="理の冠",  value="0x5")])
    async def callback(interaction):
        if select.values[0] == "0x3":
            if score >= 45:e.title="<:icons_Correct:1007531113591357450>"
            else:e.title="<:icons_Wrong:1007531146256580648>"
        elif select.values[0] == "0x5":
            if score >= 45:e.title="<:icons_Correct:1007531113591357450>"
            else:e.title="<:icons_Wrong:1007531146256580648>"
        else:
            if score >= 30:e.title="<:icons_Correct:1007531113591357450>"
            else:e.title="<:icons_Wrong:1007531146256580648>"
    select.callback = callback
    #if :
        #if score >= 45:e.title="<:icons_Correct:1007531113591357450>"
        #else:e.title="<:icons_Wrong:1007531146256580648>"
    #else:
        #if score >= 30:e.title="<:icons_Correct:1007531113591357450>"
        #else:e.title="<:icons_Wrong:1007531146256580648>"
    view = View()
    view.add_item(select)
    e.set_footer(text="20Lv想定でサブスコアのみ計算してます | Beta ver")
    await ctx.respond(embed=e, view = view)"""













